---
layout: doc
---
# 基于自适应网格的主动学习算法及其结构可靠性预测应用

::: danger
This work is based on Chinese only
:::

::: info
本文仅作简单介绍，具体细节详见[论文](/reliabilitythesis.md)
:::

::: tip
当然也可以看[PPT](/reliabilityppt.md)
:::

## 基本原理
一个结构的功能函数可定义为：
$$Z=R-S$$
其中$S$为结构上的作用（使结构产生内力和变形的原因，如荷载、不均匀沉降、温度变形、收缩变形、地震等随机变量）共同引起的效应，如弯矩$M$、轴力$N$、剪力$V$、扭矩$T$、挠度$f$、裂缝宽度$w$等；$R$为结构抗力，即结构抵抗作用效应的能力，由材料性能（强度、变形模量等）、几何参数（构件尺寸等）通过力学假设推导得出，如受弯承载力$M_u$、受剪承载力$V_u$、容许挠度$[f]$、容许裂缝宽度$[w]$等。
$Z>0$则表示结构安全可靠，$Z<0$则表示结构不安全不可靠。考虑到$R$、$S$的随机性，$Z$的取值也呈现随机性。如何求得$Z<0$的失效概率，是结构可靠性预测的主要内容。

上述问题进一步抽象如下：由$n$维随机变量构成的输入空间，在此空间上的功能函数$Z>0$的概率则表示结构的安全概率，$Z<0$的概率则表示结构的失效概率。$Z=0$称为极限状态面。

要求解其失效概率，最常见的方法即蒙特卡洛模拟。按概率抽取$n$个随机变量的一组数值，带入功能函数求$Z$。随着抽样次数的增加，频率逐渐收敛于概率。但工程结构的计算往往需要进行有限元模拟，大量抽样的计算成本十分高昂。所以实际应用中，常用搜索算法平衡抽样次数和预测精度。

## 基于自适应网格的可靠度预测算法

### 计算原理

本算法的基本原理是，采用自适应网格由粗至细的划分输入空间，在极限状态面周围网格逐渐密集细分。在功能函数为正的区域，可靠度可以通过分布函数直接求得；在功能函数存在正负的区域，网格进一步细分。当可靠度达到指定精度要求的时候，停止细分。并将最后细分的，功能函数存在正负的网格的可靠度线性插值计算后累加到总可靠度中。

### 优化原理

本算法的具体实现依赖于输入空间中点的取样。更进一步，点上功能函数的正负决定了其构成的网格的正负。由此网格被划分为安全网格、失效网格和极限状态网格。只有极限状态网格进行下一层的划分，并生成和上一层同样的拓扑结构。

上述规定的划分条件对整个输入空间网格的树状结构进行了剪枝。同时为了进一步提高算法效率，在生成网格的过程中利网格的拓扑结构，主动学习网格的顶点的正负，进一步降低了采样次数。二维的算法示意如下图：


<div style="display: flex; justify-content: center; align-items: center;  flex-direction: column;">
  <img src="/r1.svg">
  <p style="margin-top: 10px; color:#888888">自适应网格算法的二维实现</p>
</div>

## 算法提出
基于上述原理，以下提出两种算法。一种由可靠度误差控制，计算指定精度的可靠度；另一种由可靠性指标精度控制，计算指定精度的可靠性指标。方便起见，安全网格被称为正单元，失效网格被称为负单元，极限状态网格被称为正负混合单元。
### 可靠度误差监督的自适应网格算法

可靠度误差监督的自适应网格算法的原理基于以下两点：
1. 在超矩形空间自适应网格划分生成$k$层树状结构这一过程中，整个树状结构中的所有正单元包含了结构的可靠度信息，第$k$层的正负混合单元包含了结构可靠度的计算误差信息。
2. 随着层级的增加，第$k$层的正负混合单元总域逐渐减少，即有效可靠度的误差是逐层降低的。举例而言，如果$k$层树状结构中具总共出现了$p$个正单元，那么计算的结构有效可靠度为所有$\sum\limits_{i = 1}^p {R_{SE}^i}$，${R_{SE}^i}$为第$i$个正单元的可靠度；第$k$层出现了$q$个正负混合单元，若将其视为正单元，则结构的可靠度最大误差不超过$\sum\limits_{i = 1}^q {R_{SE}^j}$，$\sum\limits_{i = 1}^q {R_{SE}^j}$为第$j$个正负混合单元按照正单元计算的可靠度，且随着$k$的增加而单调减少。

算法具体流程如下图：

<div style="display: flex; justify-content: center; align-items: center;  flex-direction: column;">
  <img src="/r2.svg">
  <p style="margin-top: 10px; color:#888888">可靠度误差监督的自适应网格算法</p>
</div>

### 可靠性指标精度监督的自适应网格算法

可靠性指标精度监督的自适应网格算法的基本原理基于以下两点：
1. 可靠性指标的物理含义为极限状态面至原点的最短距离，从而最可能点只可能出现在正负混合单元中；
2. 随着层级的增加，自适应网格在极限状态面处的分辨率越来越高。

与可靠度误差监督的自适应网格算法类似，只有正负混合单元才将生成下一层的单元。同时引入加速搜索策略来进一步提高算法效率，加速搜索策略指在生成下一层的网格之前删除肯定不包含MPP的单元。举例而言，假定存在$E_1$和$E_2$两个单元，$E_1$距原点的最大距离为$l_1$，$E_2$距原点的最小距离为$l_2$，若$l_1<l_2$则说明$E_2$必然不包含最可能点因此可以删除。据此在网格划分生成下一层前，首先计算出当前层级所有正负混合单元距原点的最大距离并将其中最小的作为可靠性指标，然后让所有距原点的最小距离大于可靠性指标的单元不进行网格生成。当达到可靠性指标的精度所规定的最大层级时算法停止，用$\varepsilon_P$表示可靠性指标的精度，其与最大层级的关系如下$2m ≥|Ck|/\varepsilon_P$，其中$|Ck|$是输入空间的二范数。最后用得到的可靠性指标可用来计算可靠度。


算法具体流程如下图：

<div style="display: flex; justify-content: center; align-items: center;  flex-direction: column;">
  <img src="/r3.svg">
  <p style="margin-top: 10px; color:#888888">可靠性指标精度监督的自适应网格算法</p>
</div>

## 算法验证

以下通过高度非线性串联系统问题来验证所提算法的有效性。
$$g = \min \{ g_m^1,g_{^m}^2,g_m^3,g_m^4\} \left\{ \begin{array}{l}
g_m^i = {g^i} + 2\sin ({g^i}),i \in \{ 1,2,3,4\} \\
{g^1} = 3 + 0.1{({x_1} - {x_2})^2} - ({x_1} + {x_2})/\sqrt 2 \\
{g^2} = 3 + 0.1{({x_1} - {x_2})^2} + ({x_1} + {x_2})/\sqrt 2 \\
{g^3} = {x_1} - {x_2} + 7/\sqrt 2 \\
{g^4} = {x_2} - {x_1} + 7/\sqrt 2 
\end{array} \right.$$

其中$x_1$和$x_2$服从标准正态分布，取值区间分别为[−6,6]和[−4,4]，$g$在输入空间上的功能函数和极限状态面如下图。为比较两种算法的差异，将可靠度误差监督的自适应网格算法的最大误差设为0.001，同时将可靠性指标精度监督的自适应网格算法的可靠度指标精度设为0.1，结构的失效概率通过蒙特卡洛抽样$10^8$来进行计算。抽样结果和可靠度计算结果见下图和表格。

<div style="display: flex; justify-content: center; align-items: center;  flex-direction: column;">
  <img src="/r4.svg">
  <p style="margin-top: 10px; color:#888888">算法二维验证</p>
</div>

| 算法         | 实际抽样数量 | 预测数量 | 预测失误数量 | 失效概率              | 绝对误差              | 相对误差 | 预测错误率 |
| -------------- | ----------------- | -------- | ------------ | ------------------------- | ------------------------- | -------- | ---------- |
| 蒙特卡洛   | $1 \times 10^{8}$ | -        | -            | $2.272 \times 10^{-3}$    | -                         | -        | -          |
| 可靠度算法 | $981$               | $976$     | $58$           | $2.28367 \times 10^{-3}$  | $0.116668 \times 10^{-3}$ | $0.51%$    | $5.94%$      |
| 可靠性指标算法 | $239$               | $220$      | $6$            | $11.10167 \times 10^{-3}$ | $88.32545 \times 10^{-4}$ | $388.62%$  | $2.73%$      |

与蒙特卡洛抽样的结果对比可知，算法的可靠性预测结果准确，且具有极高的效率。

## 算法对比与应用

由于markdown和html文档展示表格十分不便，故详见[论文](/reliabilitythesis.md)